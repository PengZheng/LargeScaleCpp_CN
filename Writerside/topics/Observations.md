# 观察

## 第一章

* 编译时依赖常会导致链接时依赖。（1.8）
* 组件间的依赖关系具有传递性。（1.8）
* 只要系统能够通过编译，就可以利用C++预处理指令`#include`推断出系统中各组件之间的全部实际物理依赖。（1.11.1）

## 第二章

* 聚合之间的依赖关系具有传递性。（2.2.5）
* 任何物理聚合的定义均须包含其所聚合实体的规约及可容许依赖的规约。（2.2.14）
* 为尽可能方便人的认知，物理聚合中同级实体的物理复杂度应相当（如具有相同的物理聚合层级）。（2.2.16）
* 对于平衡得当的物理聚合来说，超过3个层级几乎总是不必要的，并且可能会导致问题。（2.2.18）
* 包组可以支持逻辑内聚和物理内聚的库开发。（2.9.3）
* 包组允许无环应用库随时间演进。（2.9.3）
* 包组支持去中心化的包创建。（2.9.4）
* 在包组中选择包名称是自动去中心化的。（2.10.3）
* 发布单元在开发过程中假定的物理粒度通常比实际部署时的粒度要粗。（2.15.9）

## 第三章

* 物理实现的依赖对模块化有着强烈的影响。（3.2.5）
* 预期的客户用途会显著影响模块化。（3.2.5）
* 迭代器常常显著减少需要实现的初等操作数量。（3.2.6）
  * 一些操作（在没有迭代器的情况下）只是在表现上初等，而非固有初等。
* 实现的灵活度会影响实现的哪些部分是初等的。（3.2.8.8）
* 如果组件自然地共享相同的物理依赖包络，那么对于按照设计必然会在语法（及语义）上相似的组件（如实现同一协议类或满足同一概念），包可以起到将它们明确分组的作用。（3.3.7）
* 包和组件的名称有时可以高效地表示设计的正交维度，但这仅限于极其规整的框架。（3.3.8）
