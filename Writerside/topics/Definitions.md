# 定义

## 第一章

* **声明**（declaration）是一种语言结构，用于在作用域中引入一个名称。（1.3.1）
* **定义**（definition）是一种语言结构，它唯一地刻画了程序中的一个实体，并在适当时为其保留存储空间。（1.3.1）
* 根据C++标准，如果一个名称可以表示在另一个作用域中声明的实体，则该名称具有**链接**（linkage）。（1.3.1）
  * 如果可以跨越编译单元引用一个逻辑实体，则称它具有**外部链接**（external linkage）。
  * 如果只能在同一个编译单元内跨越作用域引用一个逻辑实体，则称它具有**内部链接**（internal linkage）。
  * 如果一个逻辑实体不能从定义它的局部作用域外被引用，则该实体**没有链接**（no linkage）。
* 如果在典型平台上，对一种C++结构的已声明名称的使用及其对应的定义（或含义）总是在编译时有效地绑定，则此C++结构具有**内部绑定**（internal bindage）。（1.3.4）
  * 由编译器解析该实体的使用，链接器不参与解析。如类、结构体、typedef和预处理宏。
* 如果在典型平台上，一个C++结构的对应定义不能出现在程序的多个编译单元中（如为了避免链接时出现符号多重定义错误），则此C++结构具有**外部绑定**（external bindage）。（1.3.4）
  * 必须由链接器解析其使用。
* 如果在典型平台上，一个C++结构的对应定义可以安全地出现在同一程序的多个翻译单元中，并且这种结构的已声明名称的使用及其相应定义可以在链接时绑定，则此C++结构具有**双重绑定**（dual bindage）。（1.3.4）
  * 既可以由编译器解析其使用（若源代码对编译器可见且编译器选择这么做），也可以由链接器解析。如内联函数或者函数模板显式特化的隐式实例化。
* 如果某一类型出现在某函数的签名或返回类型中，则称该函数**在接口中使用**该类型。（1.7.3）
* 如果某一类型被用于某个类的任一（公共）成员函数的接口中，则称该类**在（公共）接口中使用**该类型。（1.7.3）
* 如果某一类型被用在一个函数的实现中，但不出现在它的公共（或受保护）接口中，则可以说该函数**在实现中使用**该类型。（1.7.4）
* 如果某一类型不被用于一个类的公共（或受保护）接口中，而是用于该类的成员函数，或者在该类的一个数据成员的声明中被引用，又或者（在少数情况下）私有派生出该类（是该类的私有基类），则可以说该类型**被用于类的实现中**。（1.7.4）
* **协议类**（protocol class）是这样一种类，它满足以下要求：（1.7.5）
  1. 除了非内联虚析构函数（在.cpp文件中定义），其成员函数中只有纯虚函数。
  2. 没有数据成员。
  3. 不从非协议类（直接或间接）派生。
* 如果在编译或者链接组件 y 时需要组件 x，则称组件 y **依赖**（Depends-On）组件 x。（1.8）
* 如果 y.cpp 的编译需要 x.h，则称组件 y 对于组件 x 具有**编译时依赖**（compile-time dependency）。（1.8）
* 如果（编译 y.cpp 而产生的）目标文件 y.o 中有需要链接 x.o 才能解析的未定义符号，则称组件 y 对组件 x 具有**链接时依赖**（link-time dependency）。（1.8）
* 无环物理依赖允许对（非负）层级编号进行规范分配：（1.10）
  * 层级 0：非本地组件。
  * 层级 1：不依赖任何其他本地组件的本地组件（也称为叶端组件）。
  * 层级 N：物理上依赖至少一个 N − 1（N ≥ 2）级本地组件，但不依赖 N 级或更高层级本地组件的本地组件。
* 由可赋层级编号的组件呈现的软件子系统称为**可划分层级的**（levelizable）。（1.10）
* 如果 y.h 的内容在编译时最终被纳入 x.cpp 对应的编译单元，则称组件 x **包含**（Includes）组件 y。（1.11.1）

## 第二章

* **聚合**（aggregate）是内聚的物理设计单元，由逻辑内容构成。（2.2.1）
* **组件**是最内层级的物理聚合。（2.2.2）
* **发布单元**（unit of release，UOR）是最外层级的物理聚合。（2.2.3）
* 如果对聚合 y 的编译、链接或彻底测试需要聚合 x 中的任何文件，则称聚合 y **依赖**（Depends-On）聚合 x。（2.2.5）
* 如果一逻辑或物理实体的名称（或符号）是有意从其定义所在的发布单元对外暴露的，则称该实体是**架构显著的**（architecturally significant）。（2.2.6）
* **清单**（manifest）是用于描述其所属物理聚合中的物理实体集合的规约，通常用外部元数据表示。（2.2.14）
* **可容许依赖**（allowed dependency）是被允许存在于其所属物理层级中的物理依赖关系，通常用外部元数据表示。（2.2.14）
* **包**（package）是大于组件的具有架构显著性的最小物理聚合。（2.4.5）
  * 推论：任何包的名称必须在整个企业中唯一。
* 组件的**基名**（base name）是其组件头文件的根名称，不算其包前缀和紧随其后的下划线。（2.4.7）
* **切面函数**（aspect function）是具有普遍统一语义和给定签名的具名（成员或自由）函数（例如 begin 或 swap）;当它是自由函数时，其行为类似于运算符，例如在参数依赖查找（ADL）方面。（2.4.8）
* **传递包含**意味着客户端依赖于使用一个头文件来包含另一个头文件，以便直接使用通过嵌套包含间接提供的功能。（2.6）
* **组件私有**（component-private）类或结构体是指在包级命名空间作用域定义的属于某一组件且不能被该组件之外的逻辑实体直接使用的类或结构体。（2.7.1）
* **附属组件**（subordinate component）是指这样一种组件，只有该组件所附属的（且位于同一包中的）组件才能直接使用（`#include`）它。一个组件至多只能附属于一个非附属组件。（2.7.5）
* **包**是架构显著的组件集合，这些组件被组织为物理内聚单元，并共享一个共同的包级命名空间。（2.8.1）
* **包组**（package group）是架构显著的被组织为物理内聚单元的包集合。（2.9.1）
  * 推论：任何包组的名称必须在整个企业中唯一。
* 只要包组 g 中的任何一个包依赖另一个发布单元 u，包组 g 就**依赖**发布单元 u。（2.9.1）
* 如果包不完全由恰当组件组成，则称该包是**不规整的**（irregular）。这里的恰当指的是组件符合本书中的设计规则，特别是那些与内聚命名有关的规则。（2.12）

## 第三章

* 本质上需要对其操作类型的对象进行私有访问才能高效实现的功能称为该类型的**初等操作**（primitive operation）。（3.2.5）
* 如果修改、添加或移除组件的某一实现细节（类型、数据或函数）不会强制客户修改其代码，则称该实现细节是**被封装的**（encapsulated）。（3.11.1）
* 如果修改、添加或移除组件的某一实现细节（类型、数据或函数）不会强制客户重新编译，则称该实现细节是**被隔离的**（insulated）。（3.11.1）
